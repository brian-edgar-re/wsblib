# WSBLib - How to use

Learn how to create a web server using the `WSBLib` library.

## Understanding the request cycle

First, the entire request cycle is handled by you. You manipulate the data sent by the client, process the request and send the response, all this **using the WSBLib classes**, which facilitate this whole cycle. A **request cycle using WSBLib** looks like this:

1. Receive client data (specifically a raw HTTP message);
2. Process client request;
3. Get the requested route response;
4. Send response to customer.

If you were to create this from scratch, **without using WSBLib**, you'd have to do all of this:

1. Accept client connection;
2. Receive client data (specifically a raw HTTP message);
3. Format HTTP request data;
4. Check which route was called;
5. Check if the HTTP method is accepted by the route;
6. Generate error responses if the route is not found or the method is not accepted
7. Get the requested route response;
8. Format HTTP response data;
9. Send response to customer.

We've shortened all these steps to **just 4**, making it easy to develop your framework or web server.

## Structure of a WSBLib server

Next, we will show the basic structure of a WSBLib server and explain the function of each of the classes, methods and others. Here's the [code for this simple server](https://github.com/firlast/wsblib/tree/master/examples/simple-server):

```python
from wsblib.route import Route
from wsblib.server import Client, Server
from wsblib.request import ProcessRequest
from wsblib.request import RequestData
from wsblib import log


def index():
    return 'Hello World!'


index_route = Route(index, '/')
request = ProcessRequest((index_route,))

server = Server()
server.start('127.0.0.1', 2808)

print('Server running in http://127.0.0.1:2808')

while True:
    client = server.wait_client()
    processed_request = request.process(client)

    if processed_request:
        request_data = processed_request.request
        response = processed_request.get_response()
        processed_request.send_response(response)
        log.log_request(response, request_data)
```

This example server **does not use threads**, that is, it can only serve another request after the current request is completed. You can rearrange this code so that threads are used.

### Creating routes

In the code snippet below, we create a route on the `/` path, which will call the `index_route` function to get a response and return it to the client:

```python
def index():
    return 'Hello World!'

index_route = Route(index, '/')
```

This class is used to **manipulate and obtain data** from the route requested by the user, being able to check methods, obtain parameters (for dynamic routes) and others. To ***create an instance of this class***, the required arguments are:

1. callback: Function to be called when the route is requested (`FunctionType`);
2. path: Route path (`str`);
3. methods: Route allowed methods, the default value is ('GET') (`tuple`, optional).

If we want, for example, to create a route that creates, reads, updates and deletes data (CRUD), the arguments passed would be like this:

```python
profile_route = Route(profile, '/profile', methods=('GET', 'POST', 'PUT', 'DELETE'))
```